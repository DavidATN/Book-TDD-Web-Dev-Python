[[chapter_10_production_readiness]]
== Making our App Production-Ready

Our container is working fine but it's not production-ready.
Let's try to get it there, using the tests to guide us.

In a way we're applying the Red-Green-Refactor cycle to our productionisation process.
Our hacky container config got us to Green, and now we're going to Refactor,
working incrementally (just as we would while coding),
trying to move from working state to working state,
and using the FTs to detect any regressions.


.ðŸš§ Warning, this chapter is heavily under construction
*******************************************************************************
As part of my work on the third edition of the book,
I'm rewriting the deployment chapters,
but this chapter is far from ready I'm afraid.
Sorry!

Following along with this chapter is going to be pretty
much impossible while I'm still half-done.

It might be best to skip ahead to [[chapter_12_organising_test_files]]

*******************************************************************************

=== What We Need to Do

What's wrong with our hacky container image?
A few things: first, we need to host our app on the "normal" port 80
so that people can access it using a regular URL.

Perhaps more importantly, we shouldn't use the Django dev server for production;
it's not designed for real-life workloads.
Instead, we'll use the popular Gunicorn Python/WSGI server.

((("DEBUG settings")))
Several settings in 'settings.py' are currently unacceptable too.
`DEBUG=True`, is strongly recommended against for production,
we'll want to set a unique `SECRET_KEY`, and as we'll see, other things will come up.

Let's go through and see if we can fix things one by one.



=== Switching to Gunicorn

((("production-ready deployment", "using Gunicorn", secondary-sortas="Gunicorn")))
((("Gunicorn", "switching to")))
Do you know why the Django mascot is a pony?
The story is that Django comes with so many things you want:
an ORM, all sorts of middleware, the admin site...
"What else do you want, a pony?" Well, Gunicorn stands for "Green Unicorn",
which I guess is what you'd want next if you already had a pony...

----
pip install gunicorn
pip freeze | grep -i gunicorn== >> requirements.txt
----

Gunicorn will need to know a path to a WSGI server,
which is usually a function called `application`.
Django provides one in 'superlists/wsgi.py':

----
CMD ["/venv/bin/gunicorn", "--bind", ":8888", "superlists.wsgi:application"]
----

// TODO mention new cmd syntax with ["list"]



rebuild and rerun our container:

----
podman build -t superlists . && podman run -p 8888:8888 -it superlists
----


But if we run the functional tests, once again you'll see
that they are warning us of a problem.
The test for adding list items passes happily,
but the test for layout + styling fails. Good job, tests!

[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*TEST_SERVER=localhost:8888 python manage.py test functional_tests*]
[...]
AssertionError: 117.0 != 512 within 10 delta
FAILED (failures=1)
----

And indeed, if you take a look at the site, you'll find the CSS is all broken,
as in <<site-with-broken-css>>.

The reason that the CSS is broken is that although the Django dev server will
serve static files magically for you, Gunicorn doesn't.


[[site-with-broken-css]]
.Broken CSS
image::images/twp2_1001.png["The site is up, but CSS is broken"]


One step forward, one step backward, but once again we've identified the
problem nice and early. Moving on!


=== Static Files with Whitenoise

[role="sourcecode"]
.lists/tests.py (ch00l000)
====
[source,python]
----
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    [...]

----
====


And if you take another manual look at your site, things should look much
healthier. Let's rerun our FTs:

[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*TEST_SERVER=localhost:8888 python manage.py test functional_tests --failfast*]
[...]

...
 ---------------------------------------------------------------------
Ran 3 tests in 10.718s

OK
----

Phew.



=== Using Environment Variables to Adjust Settings for Production

((("DEBUG settings")))
We know there are several things in
_settings.py_ that we want to change for production:


////
* +ALLOWED_HOSTS+ is currently set to "*" which isn't secure.  We want it
  to be set to only match the site we're supposed to be serving
  (_localhost_ for now, but someday soon, a real domain).
////

* +DEBUG+ mode is all very well for hacking about on your own server, but
  leaving those pages full of tracebacks available to the world
  https://docs.djangoproject.com/en/1.11/ref/settings/#debug[isn't secure].

* `SECRET_KEY` is used by Django for some of its crypto--things
    like cookies and CSRF protection.
    It's good practice to make sure the secret key in production is different
    from the one in your source code repo,
    because that code might be visible to strangers.
    We'll want to generate a new, random one
    but then keep it the same for the foreseeable future
    (find out more in the https://docs.djangoproject.com/en/4.2/topics/signing/[Django docs]).

Development, staging and production sites always have some differences
in their configuration.
Environment variables are a good place to store those different settings.
See http://www.clearlytech.com/2014/01/04/12-factor-apps-plain-english/[
"the 12-factor app"].footnote:[
Another common way of handling this
is to have different versions of _settings.py_ for dev and prod.
That can work fine too, but it can get confusing to manage.
Environment variables also have the advantage of working for non-Django stuff too...
]


==== Setting DEBUG=True

Here's one way to make it work:


[role="sourcecode"]
.superlists/settings.py (ch10l005)
====
[source,python]
----
import os
[...]

if "DJANGO_DEBUG_FALSE" in os.environ:  #<1>
    DEBUG = False
    SECRET_KEY = os.environ["DJANGO_SECRET_KEY"]  #<2>
else:
    DEBUG = True  #<3>
    SECRET_KEY = "insecure-key-for-dev"
----
====

<1> We say we'll use an environment variable called `DJANGO_DEBUG_FALSE`
    to switch debug mode off, and in effect require production settings
    (it doesn't matter what we set it to, just that it's there).

<2> And now we say that, if debug mode is off,
    we _require_ the `SECRET_KEY` to be set by two more environment variables

<3> Otherwise we fall-back to the insecure, debug mode settings that
    are useful for Dev.

There are other ways you might set up the logic, making various variables optional,
but I think this gives us a little bit of protection
against accidentally forgetting to set one.
The end result is that you don't need to set any of them for dev,
but production needs all three, and it will error if any are missing.

TIP: Better to fail hard than allow a typo in an environment variable name to
    leave you running with insecure settings.

Now let's set that environment variable in our Dockerfile using then `ENV` directive:

[role="sourcecode"]
.Dockerfile (ch10l006)
====
[source,dockerfile]
----
RUN /venv/bin/python manage.py migrate

ENV DJANGO_DEBUG_FALSE=1
CMD ["/venv/bin/gunicorn", "--bind", ":8888", "superlists.wsgi:application"]
----
====


==== Setting environment variables at the docker command-line

oops, forgot about the secret key:


----
    SECRET_KEY = os.environ["DJANGO_SECRET_KEY"]
                 ~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^
----

Now, we've said we can't keep the secret key in our source code,
where else can we put it?
For now, we can set it at the command line

[subs="specialcharacters,quotes"]
----
$ *podman build -t superlists . && podman run -p 8888:8888 -e DJANGO_SECRET_KEY=sekrit -it superlists*
----


And use a test run to reassure ourselves that things still work...

[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*TEST_SERVER=localhost:8888 ./manage.py test functional_tests --failfast*]
[...]
AssertionError: 'To-Do' not found in 'Bad Request (400)'
----

==== ALLOWED_HOSTS is Required When Debug Mode is Turned Off

Oops.  Let's take a look manually: <<django-400-error>>.

[[django-400-error]]
.An ugly 400 error
image::images/twp2_1002.png["An unfriendly page showing 400 Bad Request"]

Something's gone wrong.  But once again, by running our FTs frequently,
we're able to identify the problem early, before we've changed too many things.
In this case the only thing we've changed is _settings.py_. We've changed three
settingsâ€”which one might be at fault?

Let's use the "Googling the error message" technique again.

The very first link in my search results for
https://duckduckgo.com/?q=django+400+bad+request[Django 400 Bad Request]
suggests that a 400 error is usually to do with `ALLOWED_HOSTS`.
// old error with debug=true <<django-disallowedhosts-error>>


`ALLOWED_HOSTS` is a security setting
designed to reject requests that are likely to be forged, broken or malicious
because they don't appear to be asking for your site
(HTTP request contain the address they were intended for in a header called "Host").

By default, when DEBUG=True, `ALLOWED_HOSTS` effectively allows _localhost_,
our own machine, so that's why it was working OK until now.

There's more information in the
https://docs.djangoproject.com/en/4.2/ref/settings/#allowed-hosts[Django docs].

The upshot is that we need to adjust `ALLOWED_HOSTS` in _settings.py_.
Let's use another environment variable for that:


[role="sourcecode"]
.superlists/settings.py (ch10l007)
====
[source,python]
----
if "DJANGO_DEBUG_FALSE" in os.environ:
    DEBUG = False
    SECRET_KEY = os.environ["DJANGO_SECRET_KEY"]
    ALLOWED_HOSTS = [os.environ["DJANGO_ALLOWED_HOST"]]
else:
    DEBUG = True
    SECRET_KEY = "insecure-key-for-dev"
    ALLOWED_HOSTS = []
----
====

This is a setting that we want to change,
depending on whether our docker image is running locally,
or on a server, so we'll use the `-e` flag again:


[subs="specialcharacters,quotes"]
----
$ *podman build -t superlists . && \
    podman run -p 8888:8888 -e DJANGO_SECRET_KEY=sekrit -e DJANGO_ALLOWED_HOST=localhost -it superlists*
----


==== Collectstatic is required when Debug is Turned off

An FT run (or just looking at the site) reveals that we've had a regression
in our static files.

[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*TEST_SERVER=localhost:8888 python manage.py test functional_tests*]
[...]
AssertionError: 117.0 != 512 within 10 delta
FAILED (failures=1)
----


We saw this before when switching from the Django dev server to Gunicorn,
so we introduced Whitenoise. Similarly, when we switch DEBUG off,
Whitenoise stops automagically finding static files in our code,
and instead we need to run `collectstatic`:


[role="sourcecode"]
.Dockerfile (ch10l008)
====
[source,dockerfile]
----

RUN /venv/bin/python manage.py migrate
RUN /venv/bin/python manage.py collectstatic

----
====

that'll get you passing tests.  we ahve a container that we're ready to ship to production!

find out how in the next exciting installment.


[role="pagebreak-before less_space"]
.Production-Readiness Config
*******************************************************************************

((("production-ready deployment", "best practices for")))A
few things to think about when trying to build a production-ready server
[keep-together]#environment#:

Don't use the Django dev server in production::
    ((("Gunicorn", "benefits of")))Something
    like Gunicorn or uWSGI is a better tool for running Django; it
    will let you run multiple workers, for example.

Don't use Django to serve your static files::
    ((("static files", "serving with Nginx")))
    There's no point in using a Python process to do the simple job of serving
    static files. 
    TODO more here

Check your settings.py for dev-only settings::
    `DEBUG=True`, `ALLOWED_HOSTS` and `SECRET_KEY` are the ones we came across,
    but you will probably have others (we'll see more when we start to send
    emails from the server).

Security::
    ((("security issues and settings", "server security")))((("Platform-As-A-Service (PaaS)")))A
    serious discussion of server security is beyond the scope of this book,
    and I'd warn against running your own servers
    without learning a good bit more about it.
    (One reason people choose to use a PaaS to host their code
    is that it means a slightly fewer security issues to worry about.)
    If you'd like a place to start, here's as good a place as any:
    https://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers[My first 5 minutes on a server].
    I can definitely recommend the eye-opening experience of installing
    fail2ban and watching its logfiles to see just how quickly it picks up on
    random drive-by attempts to brute force your SSH login.  The internet is a
    wild place!
    TODO: this probably belongs in the next chapter too.

*******************************************************************************
