[[chapter_11_server_prep]]
== Getting A Server Ready For Deployment

.A Note for Early Release Readers
****
With Early Release ebooks, you get books in their earliest form—the author's raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.

This will be the 11th chapter of the final book. The GitHub repo is available at https://github.com/hjwp/book-example.

If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at obeythetestinggoat@gmail.com.
****

((("deployment", "automating with Ansible", id="Dfarbric11")))
((("infrastructure as code")))
This chapter is all about getting ready for our deployment.
We're going to spin up an actual server,
make it accessible on the Internet with a real domain name,
and setup the authentication and credentials we need
to be able to control it remotely with SSH and Ansible.

////
DAVID overall notes

The main challenge is that I found that when I ran into problems I lacked the
mental model to troubleshoot - it's possible that others who don't have access
to Harry(TM) will give up. I think talking through what Ansible is doing, maybe
even a diagram at the beginning of the chapter to show what we're aiming for?
In particular, it's difficult to understand where the Ansible error logs are
coming from (i.e. local, server, container...)

I also think we're missing some stuff at the end about how all this might look
as a development workflow. Maybe talk about setting up scripts (so we don't
have to remember the ansible command?) And what about releasing to production?
It doesn't need much, it just feels unfinished to me.

A few small things:

*  I think you should make more of the fact that our functional tests can be
  run against a real website hosted elsewhere. The fact that we can do that
  was not obvious to me when we wrote those tests. Worth talking about a bit
  more?

* Shouldn't we commit our changes to Git at some point, as per the
  other chapters?

* Will we be returning to this again in the book? I'd like to
  know whether I can destroy my Digital Ocean droplet yet, don't want to get
  billed needlessly.
////

////
SEBASTIAN overall notes
All in all, I am not very fond of the current shape of this chapter.

The summary is great and the choice of technologies is the best I can imagine.

However, I got lost several times while reading through the chapter.
There are too many open loops. For example, SSH is mentioned but then we jump into all other technologies without seeing what SSH is and how it will play with the rest.


I think (my opinion) the chapter needs reorganizing so that readers can more quickly see a given piece of tech in action. I'd cut some content.

If you like some more specific suggestions, I can spend more time and provide them.

Also, it's mentioned that the server will be provisioned manually without automation,
but then we get ansible infra/ansible-provision.yaml.
I must say I'm not following when provisioning starts and where it ends.
In my book (figuratively speaking),
installing docker falls under the definition of provisioning
(which was meant NOT to be automated)
while the remaining steps, like exporting and reimporting docker image,
are something different (deployment?).
////

.Warning, chapter under construction
****
As part of my work on the third edition of the book,
I'm making big changes to the deployment chapters.
This chapter is still a little "bare bones"
and could do with a bit more explanatory content and guidance,
but the core steps are all there, so I hope you'll be able to follow along.

So as always I really, really need feedback.
So please hit me up at obeythetestinggoat@gmail.com, or via
https://github.com/hjwp/Book-TDD-Web-Dev-Python/issues[GitHub Issues]
and Pull Requests.

I hope you enjoy the new version!
****


=== Getting a Domain Name

((("domain names")))
We're going to need a couple of domain names at this point in the book--they
can both be subdomains of a single domain.
I'm going to use _superlists.ottg.co.uk_ and _staging.ottg.co.uk_.
If you don't already own a domain, this is the time to register one!
Again, this is something I really want you to _actually_ do.
If you've never registered a domain before,
just pick any old registrar and buy a cheap one--it
should only cost you $5 or so, and you can even find free ones.
I promise seeing your site on a "real" website will be a thrill.

// DAVID: just wondering if it's worth giving them the option to cheat and
// specify a domain name in a hosts file?


=== Manually Provisioning a Server to Host Our Site

// TODO: revise this section?  I used to assume provisioning included installing dependencies,
// but now we have docker, so at least some of that job is part of deployment after all.


// HP: ok taking on suggestion from earlier,
// maybe get rid of the provisioning/deployment distinction,
// and instead talk about "spinning up" aka "starting" a server being the only manual step


((("staging sites", "manual server provisioning", id="SSserver09")))
((("server provisioning", id="seerver09")))
We can separate out "deployment" into two tasks:

- _Provisioning_ a new server to be able to host the code
- _Deploying_ a new version of the code to an existing server

Infrastructure-as-code tools can let you automate both of these,
but the provisioning parts tend to be quite vendor-specific,
so for the purposes of this book, we can live with manual provisioning.

NOTE: I should probably stress once more that deployment is something that varies a lot,
  and that as a result there are few universal best practices for how to do it.
  So, rather than trying to remember the specifics of what I'm doing here,
  you should be trying to understand the rationale,
  so that you can apply the same kind of thinking in the specific future circumstances you encounter.


==== Choosing Where to Host Our Site

((("hosting services")))
There are loads of different solutions out there these days,
but they broadly fall into two camps:

- Running your own (probably virtual) server
- Using a ((("Platform-As-A-Service (PaaS)")))Platform-As-A-Service (PaaS)
  offering like Heroku or my old employers, PythonAnywhere.

((("PythonAnywhere")))
Particularly for small sites,
a PaaS offers a lot of advantages over running your own server,
and I would definitely recommend looking into them.
We're not going to use a PaaS in this book however, for several reasons.
The main reason is that I want to avoid endorsing specific commercial providers.
Secondly, all the PaaS offerings are quite different,
and the procedures to deploy to each vary a lot--learning about one
doesn't necessarily tell you about the others.
Any one of them might radically change their process or business model by the time you get to read this book.

Instead, we'll learn just a tiny bit of good old-fashioned server admin,
including SSH and manual debugging.
They're unlikely to ever go away,
and knowing a bit about them will get you some respect
from all the grizzled dinosaurs out there.

// SEBASTIAN: Nice, and seem-to-be timeless choice!


==== Spinning Up Our Own Server

I'm not going to dictate how you spin up a server--whether
you choose Amazon AWS, Rackspace, Digital Ocean, your own server in a data centre,
or a Raspberry Pi in a cupboard under the stairs,
any solution should be fine, as long as:

* Your server is running Ubuntu 22.04 (aka "Jammy/LTS").

* You have root access to it.

* It's on the public internet (ie, it has a public IP address).

* You can SSH into it.

I'm recommending Ubuntu as a distro:footnote[
Linux as an operating system comes in lots of different flavours,
called "distros" or "distributions".
The differences between them and their relative pros and cons are,
like any seemingly minor detail, of tremendous interest to the right kind of nerd.
We don't need to care about them for this book. As I say, Ubuntu is fine.]
because it's popular and I'm used to it.
If you know what you're doing, you can probably get away with using
something else, but I won't be able to help you as much if you get stuck.


////
TODO: feedback from stephanie g:
I'm a little unclear if Digital Ocean is a PaaS like Heroku or not.
I think no because you wrote that we wouldn't use PaaS
but I don't really understand the distinction of "spinning up a server with PaaS"
vs "spinning up a server without a PaaS" 

I didn't (still don't really) know what a "distro" is, [done]
what Ubuntu's alternatives are, [done]
or how to tell "what a server is running," 
how to make sure I have root access to it and can SSH into it.
Or why we make a non root user.

Generally, I'm having trouble mapping all these things
(PaaS, hosting a server, Digital Ocean, Ubuntu, Linux, Ansible, etc.)
and their relationship to each other
////

.Step-by-step Instructions for Spinning up a Server
*******************************************************************************
((("Linux servers")))
I appreciate that, if you've never started a Linux server before
and you have absolutely no idea where to start,
this is a big ask, especially when I'm refusing to "dictate"
exactly how to do it.

With that in mind, I wrote a
https://github.com/hjwp/Book-TDD-Web-Dev-Python/blob/main/server-quickstart.md[very brief guide on GitHub].

I didn't want to include it in the book itself because,
inevitably, I do end up specifying a specific commercial provider in there.

*******************************************************************************

NOTE: Some people get to this chapter, and are tempted to skip the domain bit,
    and the "getting a real server" bit, and just use a VM on their own PC.
    Don't do this.
    It's _not_ the same, and you'll have more difficulty following the instructions,
    which are complicated enough as it is.
    If you're worried about cost, have a look at the guide I wrote for free options.
    ((("getting help")))



////

TODO: good advice but not quite sure it's phrased quite right for the new version of the chapter.

.General Server Debugging Tips
*******************************************************************************

The most important lesson to remember from this chapter is,
as always but more than ever, to work incrementally,
make one change at a time, and run your tests frequently.

When things (inevitably) go wrong, resist the temptation to flail about
and make other unrelated changes in the hope that things will start working again;
instead, stop, go backward if necessary to get to a working state,
and figure out what went wrong before moving forward again.

It's just as easy to fall into the Refactoring-Cat trap on the server!

*******************************************************************************
////

// JAN: It feels a bit like something is missing here. You're talking about servers and DNS records. Yet, there's no real call to action for a reader.
// I ended up executing the initial Ansible command when I realized I should've already spun up the server and set DNS records.
// I'd suggest being more specific about what should I do as a reader. No need to go step by step. Just to clearly state: "Spin up your publicly accessible server", "Now set DNS A records that point to your server"
// JAN: It would also make sense to tell the reader to point both domains to the same server

// JAN: It would also be beneficial to state at least some range of server size (e.g., 2GB of memory). e.g., the smallest EC2 instances can have quite some troubles when running Django in Docker


=== Configuring DNS for Staging and Live Domains

We don't want to be messing about with IP addresses all the time,
so we should point our staging and live domains to the server.
At my registrar, the control screens looked a bit like <<registrar-control-screens>>.

[[registrar-control-screens]]
.Domain setup
image::images/gandi_add_dns_a_record.png["Registrar control screen for adding a DNS record"]


((("A-Records")))
In the DNS system, pointing a domain at a specific IP address is called an "A-Record".footnote:[
Strictly speaking, A-records are for IPv4,
and you can also use AAAA-records for IPv6.
Some cheap providers only support IPv6,
and there's nothing wrong with that.]
All registrars are slightly different,
but a bit of clicking around should get you to the right screen in yours.
You'll need two A-records:
one for the staging address and one for the live one.
No need to worry about any other type of record.

DNS records take some time to "propagate" around the world
(it's controlled by a setting called "TTL", Time To Live),
so once you've set up your A-record,
you can check its progress on a "propagation checking" service like this one:
https://www.whatsmydns.net/#A/staging.ottg.co.uk.

I'm planning to host my staging server at _staging.ottg.co.uk_


=== Ansible

Infrastructure-as-code tools, also called "configuration management" tools,
come in lots of shapes and sizes.
Chef and Puppet were two of the original ones,
and you'll probably come across Terraform,
which is particularly strong on managing cloud services like AWS.

// SEBASTIAN: mentioning of too many technologies (e.g. Puppet/Chef - IMHO not necessary in 2024).

We're going to use Ansible, because it's relatively popular,
because it can do everything we need it to,
because I'm biased that it happens to be written in Python,
and because it's probably the one I'm personally most familiar with.

Another tool could probably have worked just as well!
The main thing to remember is the _concept_, which is that,
as much as possible we want to manage our server configuration _declaratively_,
by expressing the desired state of the server in a particular configuration syntax,
rather than specifying a procedural series of steps to be followed one by one.

==== Ansible vs SSH: How we'll Talk to our Server

See <<ansible-and-ssh>>.

[[ansible-and-ssh]]
.Ansible and SSH
image::images/ansible-and-ssh.png["Diagram "]

Our objective is to use Ansible to automate the process of deploying to our server:
making sure that the server has everything it needs to run our app
(mostly, Docker and our container image),
and then telling it to start or restart our container.

Now and again, we'll want to "log on" to the server and have a look around manually:
for that, we'll use the `ssh` command-line on our computer,
which can let us open up an interactive console on the server.

Finally, we'll run our functional tests against the server, once it's running our app,
to make sure it's all working correctly.


=== Start by Making Sure We Can SSH In

At this point and for the rest of the book,
I'm assuming that you have a nonroot user account set up,
and that it has "sudo" privileges,
so whenever we need to do something that requires root access, we use sudo,
(or "become" in Ansible terminology);
I'll be explicit about that in the various instructions that follow.

My user is called "elspeth", but you can call yours whatever you like!
Just remember to substitute it in all the places I've hardcoded it.
See the guide I wrote if you need tips on creating a sudo user.


==== Test login using SSH

Ansible uses SSH under the hood to talk to the server,
so checking we can log in "manually" is a good first step:


[role="server-commands"]
[subs="specialcharacters,quotes"]
----
$ *ssh elspeth@staging.superlists.ottg.co.uk*
elspeth@server$: *echo "hello world"*
hello world
----


* TODO: suggest passwordless login with keypairs?


.Security
*******************************************************************************
A serious discussion of server security is beyond the scope of this book,
and I'd warn against running your own servers
without learning a good bit more about it.
(One reason people choose to use a PaaS to host their code
is that it means a slightly fewer security issues to worry about.)
If you'd like a place to start, here's as good a place as any:
https://blog.codelitt.com/my-first-10-minutes-on-a-server-primer-for-securing-ubuntu/

I can definitely recommend the eye-opening experience of installing
fail2ban and watching its logfiles to see just how quickly it picks up on
random drive-by attempts to brute force your SSH login.  The internet is a
wild place!
((("security issues and settings", "server security")))
((("Platform-As-A-Service (PaaS)")))
*******************************************************************************



==== Installing Ansible

Take a look at the
https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html[Ansible installation guide]
for all the various options,
but probably the simplest thing to do is to install Ansible into the virtualenv
on our local machine:

[subs="specialcharacters,quotes"]
----
$ *pip install ansible*
# we also need the Docker SDK for the ansible/docker integration to work:
$ *pip install docker*
----

// TODO: consider introducing an explicit requirements.dev.txt here,
// with -r requirements.txt and put ansible, docker, and selenium in there.
// or, maybe get that in place in the previous chapter, keep this one shorter.


==== A First Cut of an Ansible Playbook

Let's dip our toes into Ansible,
and see if we can get it to run a simple "hello world" container on our server.

Here's what's called a "playbook" in Ansible terminology.
It's in a format called YAML (Yet Another Markup Language),
which, if you've never come across before,
you will soon develop a love-hate relationshipfootnote:[
The "love" part is that YAML is very easy to _read_ and scan through at a glance.
The "hate" part is that the actual syntax is surprisingly fiddly to get right:
the difference between lists and key/value maps is subtle
and I can never quite remember it honestly.]
for.

// JAN: It would be worth mentioning what to do to be able to execute this ansible command. I haven't noticed anything about adding a record to authorized_keys

// DAVID: I didn't know if this was an example or a file to create.
// I think it's the latter, it would be good to make that clear.

// CSANAD: I would make it more obvious we created another directory for the
//         ansible file.

Let's create a new folder called _infra_ at the top level of our project,
and we'll put the provisioning script in there:


// TODO: rename this to "deploy.yaml" maybe? cf comment eaelir re provisioning vs deploying

[role="sourcecode"]
.infra/ansible-provision.yaml (ch11l001)
====
[source,yaml]
----
---
- hosts: all

  tasks:

    - name: Install docker  #<1>
      ansible.builtin.apt:  #<2>
        name: docker.io  #<3>
        state: latest
        update_cache: true
      become: true

    - name: Run test container
      community.docker.docker_container:
        name: testcontainer
        state: started
        image: busybox
        command: echo hello world
      become: true
----
====

<1> An Ansible playbook is a series of "tasks"
  (so in that sense it's still quite sequential and procedural),
  but the individual tasks themselves are quite declarative.
  Each one usually has a human-readable `name` attribute.

<2> Each task uses an Ansible "module" to do its work.
  This one uses the `builtin.apt` module which provides a wrapper
  around the `apt` Debian & Ubuntu package management tool.

<3> Each module then provides a bunch of parameters which control how it works.
    Here we specify the `name` of the package we want to install ("docker.io"footnote:[
    In the official docker installation instructions,
    you'll see a recommendation to install docker via a private package repository.
    I wanted to avoid that complexity for the book,
    but you should probably follow those instructions in a real-world scenario,
    to make sure your version of Docker has all the latest security patches.])
    and tell it to update its cache first, which is required on a fresh server.

Most Ansible modules have pretty good documentation,
check out the `builtin.apt` one for example;
I often skip to the
https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_module.html#examples[Examples section].

Once we have our playbook, the command to actually execute the playbook against our server is `ansible-playbook`.
We pass in our nonroot username with `--user`,
and the `-i` flag points at the server we want to talk to.
`-vv` says to print out medium-verbose output.

[subs="specialcharacters,macros"]
----
$ pass:quotes[*ansible-playbook --user=elspeth -i staging.ottg.co.uk, infra/ansible-provision.yaml -vv*]
ansible-playbook [core 2.16.3]
  config file = None
  [...]
No config file found; using defaults
BECOME password:
Skipping callback 'default', as we already have a stdout callback.
Skipping callback 'minimal', as we already have a stdout callback.
Skipping callback 'oneline', as we already have a stdout callback.

PLAYBOOK: ansible-provision.yaml **********************************************
1 plays in infra/ansible-provision.yaml

PLAY [all] ********************************************************************

TASK [Gathering Facts] ********************************************************
task path: ...goat-book/superlists/infra/ansible-provision.yaml:2
ok: [staging.ottg.co.uk]
PLAYBOOK: ansible-provision.yaml **********************************************
1 plays in infra/ansible-provision.yaml

TASK [Install docker] *********************************************************
task path: ...goat-book/superlists/infra/ansible-provision.yaml:6
ok: [staging.ottg.co.uk] => {"cache_update_time": 1708981325, "cache_updated": true, "changed": false}


TASK [Install docker] *************************************************************************************************************
task path: ...goat-book/superlists/infra/ansible-provision.yaml:6
changed: [staging.ottg.co.uk] => {"cache_update_time": [...]
"cache_updated": true, "changed": true, "stderr": "", "stderr_lines": [],
"stdout": "Reading package lists...\nBuilding dependency tree...\nReading [...]
information...\nThe following additional packages will be installed:\n
wmdocker\nThe following NEW packages will be installed:\n  docker wmdocker\n0

TASK [Run test container] *****************************************************
task path: ...goat-book/superlists/infra/ansible-provision.yaml:13
changed: [staging.ottg.co.uk] => {"changed": true, "container":
{"AppArmorProfile": "docker-default", "Args": ["hello", "world"], "Config":
[...]

PLAY RECAP ********************************************************************
staging.ottg.co.uk         : ok=3    changed=2    unreachable=0    failed=0
skipped=0    rescued=0    ignored=0
----

// DAVID: rather than having to edit the username and domains each time,
// what about getting the reader to set them as environment variables at the beginning of the chapter?


I don't know about you, but whenever I make a terminal spew out a stream
of output, I like to make little _brrp brrp brrp_ noises, a bit like the
computer Mother, in _Alien_.
Ansible scripts are particularly satisfying in this regard.


TIP: You may need to use the `--ask-become-pass` argument to `ansible-playbook`
    if you get an error "Missing sudo password".


=== SSHing Into the Server and Viewing Container Logs

Time to get into some good old-fashioned sysadmin!
Let's SSH into our server and see if we can see any evidence that our container has run.

We use `docker ps -a` to view all containers, including old/stopped ones,
and we can use `docker logs` to view the output from one of them:


[role="server-commands"]
[subs="specialcharacters,quotes"]
----
$ *ssh elspeth@staging.superlists.ottg.co.uk*
Welcome to Ubuntu 22.04.4 LTS (GNU/Linux 5.15.0-67-generic x86_64)
 [...]

elspeth@server$ *docker ps -a*
CONTAINER ID   IMAGE     COMMAND              CREATED      STATUS
PORTS     NAMES
3a2e600fbe77   busybox   "echo hello world"   2 days ago   Exited (0) 10
minutes ago             testcontainer

elspeth@server:$ *docker logs testcontainer*
hello world
----

// CSANAD: we haven't set up rootless docker and haven't added the user to the
//         `docker` group either, so `docker ps` would only run with sudo.

// DAVID: Got
// permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock
// Sudo fixed it.
// Update: I think better to add my user to the docker group before this point.

TIP: Look out for that `elspeth@server`
    in the command-line listings in this chapter.
    It indicates commands that must be run on the server,
    as opposed to commands you run on your own PC.


SSHing in to check things worked is a key server debugging skill!
It's something we want to practice on our staging server,
because ideally we'll want to avoid doing it on production machines.

Let's move on to trying to get our actual docker container running on the server.
As we go through, you'll see that we're going to work through very similar issues
to the ones we've already figured our way through in the last couple of chapters:

* Configuration
* Networking
* And the database.

////

TODO: add user to docker group:


# 
- name: Add our user to the docker group, so we don't need sudo/become
  ansible.builtin.user:
    name: '{{ ansible_user }}'
    groups: docker

- name: Reset ssh connection to allow the user/group change to take effect
  ansible.builtin.meta: reset_connection




////
old content follows


Use Vagrant to Spin Up a Local VM
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Running tests against the staging site gives us the ultimate confidence that
things are going to work when we go live, but we can also use a VM on our
local machine.

Download Vagrant and Virtualbox, and see if you can get Vagrant to build a
dev server on your own PC, using our Ansible playbook to deploy code to it.
Rewire the FT runner to be able to test against the local VM.

Having a Vagrant config file is particularly helpful when working
in a team--it helps new developers to spin up servers that look exactly
like yours.((("", startref="ansible29")))




Deploying to Live
^^^^^^^^^^^^^^^^^

TODO update this

So, let's try using it for our live site!

[role="small-code against-server"]
[subs=""]
----
$ <strong>fab deploy:host=elspeth@superlists.ottg.co.uk</strong>

Done.
Disconnecting from elspeth@superlists.ottg.co.uk... done.
----


'Brrp brrp brpp'. You can see the script follows a slightly different path,
doing a `git clone` to bring down a brand new repo instead of a `git pull`.
It also needs to set up a new virtualenv from scratch, including a fresh
install of pip and Django. The `collectstatic` actually creates new files this
time, and the `migrate` seems to have worked too.



=== Git Tag the Release


((("Git", "tagging releases")))
One final bit of admin.
In order to preserve a historical marker,
we'll use Git tags to mark the state of the codebase
that reflects what's currently live on the server:

[role="skipme"]
[subs="specialcharacters,quotes"]
----
$ *git tag LIVE*
$ *export TAG=$(date +DEPLOYED-%F/%H%M)*  # this generates a timestamp
$ *echo $TAG* # should show "DEPLOYED-" and then the timestamp
$ *git tag $TAG*
$ *git push origin LIVE $TAG* # pushes the tags up
----

Now it's easy, at any time, to check what the difference is
between our current codebase and what's live on the servers.
This will come in useful in a few chapters,
when we look at database migrations.
Have a look at the tag in the history:

[subs="specialcharacters,quotes"]
----
$ *git log --graph --oneline --decorate*
[...]
----

////

// RITA: Perhaps add the note about the reader emailing you when their site goes live to this point. "Tell your mum! Tell me! Email me at....""
You now have a live website!  Tell all your friends!
Tell your mum, if no one else is interested!
Or, tell me!  I'm always delighted to see a new reader's site!
obeythetestinggoat@gmail.com

In the next chapter, it's back to coding again.((("", startref="Fstage11")))

// DAVID: maybe more of a conclusion here? It's quite a heavy chapter,
// a bit of an anticlimax to stop here. I want some inspiring note to end on.
// In particular, how does this tie into TDD?
// DAVID: Also - now it's on staging, should we release to prod too?



[role="pagebreak-before less_space"]
.Server prep recap
*******************************************************************************


* server
* SSH
* DNS

*******************************************************************************
