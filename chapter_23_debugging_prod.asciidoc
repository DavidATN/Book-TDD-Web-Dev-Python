[[chapter_23_debugging_prod]]
== Debugging Production Issues

.Warning, Chapter Update in Progress
*******************************************************************************
üöß Warning, Chapter update for 3e in progress.

This chapter has only been partially updated to Django 5, Ansible+Docker, etc.

Following along may be tricky, but I hope to have it in better shape soon!
*******************************************************************************


Popping a few layers off the stack of things we're working on:
we have nice wait-for helpers; what were we using them for?
Oh yes, waiting to be logged in. And why was that?
Ah yes, we had just built a way of pre-authenticating a user.



=== The Proof Is in the Pudding: Using Staging to Catch Final Bugs

((("debugging", "server-side", "using staging sites", tertiary-sortas="staging sites", id="DBserstag21")))
((("staging sites", "catching final bugs with", id="SScatch21")))
They're all very well for running the FTs locally,
but how would they work against the staging server?
Let's try to deploy our site.
Along the way we'll catch an unexpected bug (that's what staging is for!),
and then we'll have to figure out a way of managing the database on the test server:

[role="against-server small-code"]
[subs="specialcharacters,quotes"]
----
$ pass:quotes[*ansible-playbook --user=elspeth -i staging.ottg.co.uk, infra/deploy-playbook.yaml.yaml -vv*]

PLAYBOOK: deploy-playbook.yaml.yaml ***********************************************
1 plays in infra/deploy-playbook.yaml.yaml
[...]
----


Here's what happens when we run the functional tests:

[role="against-server small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*TEST_SERVER=staging.ottg.co.uk python src/manage.py test functional_tests*]

======================================================================
ERROR: test_logged_in_users_lists_are_saved_as_my_lists (functional_tests.test_
my_lists.MyListsTest.test_logged_in_users_lists_are_saved_as_my_lists)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "...goat-book/functional_tests/test_my_lists.py", line 34, in
test_logged_in_users_lists_are_saved_as_my_lists
    self.wait_to_be_logged_in(email)
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: Log out


======================================================================
FAIL: test_login_using_magic_link (functional_tests.test_login.LoginTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "...goat-book/functional_tests/test_login.py", line 22, in
test_login_using_magic_link
    self.wait_for(lambda: self.assertIn(
[...]
AssertionError: 'Check your email' not found in 'Server Error (500)'

 ---------------------------------------------------------------------
Ran 8 tests in 68.602s

FAILED (failures=1, errors=1)

----

We can't log in--either with the real email system or with our pre-authenticated session.
Looks like our nice new authentication system is crashing the server.


Let's practice a bit of production debugging!


=== Trying to Repro in Docker

One of the reasons we went to the trouble of building a Docker image,
was to have a way of simulating what's on the server as closely as possible, locally.
So let's see whether we get the same error if we test against Docker.

Let's rebuild and start our Docker container locally,
on port 8888:

[subs="specialcharacters,quotes"]
----
$ *docker build -t superlists . && docker run \
    -p 8888:8888 \
    --mount type=bind,source=./src/db.sqlite3,target=/src/db.sqlite3 \
    -e DJANGO_SECRET_KEY=sekrit \
    -e DJANGO_ALLOWED_HOST=localhost \
    -it superlists*
----

And now let's see if our errors repro against Docker:


[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*TEST_SERVER=localhost:8888 python src/manage.py test functional_tests*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate element: #id_logout; [...]
[...]
AssertionError: 'Check your email' not found in 'Server Error (500)'
[...]
FAILED (failures=1, errors=1)
----

Sure enough, same two errors!

// TODO: actually, does this obviate the whole need for running fts against the server?


=== Inspecting the Docker Container Logs

((("logging")))
((("Gunicorn", "logging setup")))
When Django fails with a 500 or "Unhandled Exception" and DEBUG is off,
it doesn't print the tracebacks to your web browser.
But it will send them to your logs instead.

.Check our Django LOGGING settings
*******************************************************************************

It's worth double checking at this point that your _settings.py_
still contains the `LOGGING` settings which will actually send stuff
to the console:

[role="sourcecode currentcontents"]
.src/superlists/settings.py
====
[source,python]
----
LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "handlers": {
        "console": {"class": "logging.StreamHandler"},
    },
    "loggers": {
        "root": {"handlers": ["console"], "level": "INFO"},
    },
}
----
====

Restart the Docker container if necessary,
and then either rerun the FT, or just try to log in manually.
*******************************************************************************

If you switch to the terminal that's running your Docker image,
you should see the traceback printed out in there:

[role="skipme"]
[subs="specialcharacters,quotes"]
----
Internal Server Error: /accounts/send_login_email
Traceback (most recent call last):
[...]
  File "/src/accounts/views.py", line 16, in send_login_email
    send_mail(
    ~~~~~~~~~^
        "Your login link for Superlists",
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<2 lines>...
        [email],
        ^^^^^^^^
    )
    ^
[...]
    self.connection.sendmail(
    ~~~~~~~~~~~~~~~~~~~~~~~~^
        from_email, recipients, message.as_bytes(linesep="\r\n")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
  File "/usr/local/lib/python3.13/smtplib.py", line 876, in sendmail
    raise SMTPSenderRefused(code, resp, from_addr)
smtplib.SMTPSenderRefused: (530, b'5.7.0 Authentication Required. [...]
----

That looks like a pretty good clue to what's going on.

Before we go further, it's worth confirming that the error on the actual server
is the same as the one we see in Docker.

SSH in to your server and run `docker logs`:

[role="server-commands"]
[subs="specialcharacters,quotes"]
----
elspeth@server:$ *docker logs superlists*
----

You should see an error like this:
[role="skipme small-code"]
[subs="specialcharacters,quotes"]
----
‚ùØ ssh elspeth@staging.ottg.co.uk docker logs superlists
[2024-10-30 09:55:08 +0000] [6] [INFO] Starting gunicorn 22.0.0
[2024-10-30 09:55:08 +0000] [6] [INFO] Listening at: http://0.0.0.0:8888 (6)
[2024-10-30 09:55:08 +0000] [6] [INFO] Using worker: sync
[2024-10-30 09:55:08 +0000] [7] [INFO] Booting worker with pid: 7
Not Found: /favicon.ico
Not Found: /favicon.ico
Not Found: /favicon.ico
Not Found: /favicon.ico
Not Found: /favicon.ico
Internal Server Error: /accounts/send_login_email
Traceback (most recent call last):
  File "/venv/lib/python3.13/site-packages/django/core/handlers/exception.py",
  line 55, in inner
    response = get_response(request)
  File "/venv/lib/python3.13/site-packages/django/core/handlers/base.py", line
  197, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "/src/accounts/views.py", line 16, in send_login_email
    send_mail(
    ~~~~~~~~~^
        "Your login link for Superlists",
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[...]
    raise SMTPSenderRefused(code, resp, from_addr)
smtplib.SMTPSenderRefused: (530, b'5.7.0 Authentication Required. [...]
----


Sure enough!  Good to know our local Docker setup can repro the error on the server.
((("", startref="SScatch21")))((("", startref="DBserstag21")))


=== Another Environment Variable In Docker

So, Gmail is refusing to send our emails, is it?  Now why might that be?
Ah yes, we haven't told the server what our password is!


As you might remember from earlier chapters,
our _settings.py_ expects to get the email server password from an environment variable
named `EMAIL_PASSWORD`:

[role="sourcecode currentcontents"]
.src/superlists/settings.py
====
[source,python]
----
EMAIL_HOST_PASSWORD = os.environ.get("EMAIL_PASSWORD")
----
====


Let's add this new environment variable to our local Docker container `run`
command:

First, set your email password in your terminal if you need to:

[subs="specialcharacters,quotes"]
----
$ *echo $EMAIL_PASSWORD*
# if that's empty, let's set it:
$ *export EMAIL_PASSWORD="yoursekritpasswordhere"*
----

Now let's pass that env var thru to our docker container using one more `-e` flag,
this one fishing the env var out of the shell we're in:


[subs="specialcharacters,quotes"]
----
$ *docker build -t superlists . && docker run \
    -p 8888:8888 \
    --mount type=bind,source=./src/db.sqlite3,target=/src/db.sqlite3 \
    -e DJANGO_SECRET_KEY=sekrit \
    -e DJANGO_ALLOWED_HOST=localhost \
    -e EMAIL_PASSWORD \  <1>
    -it superlists*
----

<1> If you use `-e` without an `=something` argument, it sets the env var inside Docker
    to the same value set in the current shell.
    It's like saying `-e EMAIL_PASSWORD=$EMAIL_PASSWORD`


And now we can rerun our FT again.
We'll narrow it down to just the `test_login` test since that's the main one that has a problem:

[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*TEST_SERVER=localhost:8888 python src/manage.py test functional_tests.test_login*]
[...]
ERROR: test_login_using_magic_link
(functional_tests.test_login.LoginTest.test_login_using_magic_link)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "...goat-book/src/functional_tests/test_login.py", line 32, in
test_login_using_magic_link
    email = mail.outbox.pop()
IndexError: pop from empty list
----

Aha!  The tests get a little further.
It looks like our server _can_ now send emails,
(and the docker log no longer shows any errors),
they're just not appearing in `mail.outbox`.

The reason is that `mail.outbox` is a local, in-memory variable in Django,
so that's only going to work when our tests and our server are running in the same process, like they do with unit tests or with `LiveServerTestCase` FTs.

When we run against another process, be it Docker or an actual server,
we can't access the same `mail.outbox` variable.

We need another technique if we want to actually inspect the emails
that the server sends, in our tests against Docker or the server.


=== Deciding How to Test "Real" Email Sending

This is a point at which we have to explore some tradeoffs.
There are a few different ways we could test this:

1. We could build a "real" end-to-end test, and have our tests
   log in to an email server, and retrieve the email from there.
   That's what I did in the first and second edition.

2. You can use a service like Mailinator or Mailsac,
   which give you an email account to send to,
   and some APIs for checking what mail has been delivered.

2. We could give up on testing email on the server.
   If we have a minimal smoke test that the server _can_ send emails,
   then we don't need to test that they are _actually_ delivered.

3. We can use an alternative, fake email backend,
   whereby Django will save the emails to a file on disk for example,
   and we can inspect them there.


I'm not going to explore option 2 in this book,
since it involves a commercial service and I don't want to endorse one,
but that's not to say it's a bad option.
Especially since they have free plans these days!

But let's explore the other three options (1, 2 and 4) and their pros+cons.


=== How to Test Email End-To-End with POP3

Here's an example helper function that can retrieve a real email
from a real POP3 email server,
using the horrifically tortuous Python standard library POP3 client.

To make it work, we'll need an email address to receive the email.
I signed up for a Yahoo account for testing,
but you can use any email service you like, as long as it offers POP3 access.

You will need to set the
`RECEIVER_EMAIL_PASSWORD` environment variable in the console that's running the FT.

[subs="specialcharacters,quotes"]
----
$ *echo RECEIVER_EMAIL_PASSWORD=otheremailpasswordhere >> .env*
$ *set -a; source .env; set +a*
----

[role="sourcecode skipme"]
.src/functional_tests/test_login.py (ch23l001)
====
[source,python]
----
import os
import poplib
import re
impot time
[...]

def retrieve_pop3_email(receiver_email, subject, pop3_server, pop3_password):
    email_id = None
    start = time.time()
    inbox = poplib.POP3_SSL(pop3_server)
    try:
        inbox.user(receiver_email)
        inbox.pass_(pop3_password)
        while time.time() - start < POP3_TIMEOUT:
            # get 10 newest messages
            count, _ = inbox.stat()
            for i in reversed(range(max(1, count - 10), count + 1)):
                print("getting msg", i)
                _, lines, __ = inbox.retr(i)
                lines = [l.decode("utf8") for l in lines]
                print(lines)
                if f"Subject: {subject}" in lines:
                    email_id = i
                    body = "\n".join(lines)
                    return body
            time.sleep(5)
    finally:
        if email_id:
            inbox.dele(email_id)
        inbox.quit()
----
====

If you're curious, I'd encourage you to try this out in your FTs.
It definitely _can_ work.
But, having tried it in the first couple of editions of the book.
I have to say it's fiddly to get right,
and often flaky, which is a highly undesirable property for a testing tool.
So let's leave that there for now.

TIP: If you _do_ want to test email end-to-end,
  I'd encourage you to investigate services like Mailinator or Mailsac,
  rather than trying to use POP3 directly.


=== Using a Fake Email Backend For Django

Let's say that, if we detect an environment variable `EMAIL_FILE_PATH`,
we switch to Django's file-based backend:


.src/superlists/settings.py (ch23l002)
====
[source,python]
----
EMAIL_HOST = "smtp.gmail.com"
EMAIL_HOST_USER = "obeythetestinggoat@gmail.com"
EMAIL_HOST_PASSWORD = os.environ.get("EMAIL_PASSWORD")
EMAIL_PORT = 587
EMAIL_USE_TLS = True
# Use fake file-based backend if EMAIL_FILE_PATH is set
if "EMAIL_FILE_PATH" in os.environ:
    EMAIL_BACKEND = "django.core.mail.backends.filebased.EmailBackend"
    EMAIL_FILE_PATH = os.environ["EMAIL_FILE_PATH"]
----
====

Here's how we can adapt our tests to conditionally use the email file,
instead of Django's `mail.outbox`, if the env var is set when running our tests:



[role="sourcecode"]
.src/functional_tests/test_login.py (ch23l003)
====
[source,python]
----
class LoginTest(FunctionalTest):
    def retrieve_email_from_file(self, sent_to, subject, emails_dir):  # <1>
        latest_emails_file = sorted(Path(emails_dir).iterdir())[-1]  # <2>
        latest_email = latest_emails_file.read_text().split("-" * 80)[-1]  # <3>
        self.assertIn(subject, latest_email)
        self.assertIn(sent_to, latest_email)
        return latest_email

    def retrieve_email_from_django_outbox(self, sent_to, subject):  # <4>
        email = mail.outbox.pop()
        self.assertIn(sent_to, email.to)
        self.assertEqual(email.subject, subject)
        return email.body

    def wait_for_email(self, sent_to, subject):  # <5>
        """
        Retrieve email body,
        from a file if the right env var is set,
        or get it from django.mail.outbox by default
        """
        if email_file_path := os.environ.get("EMAIL_FILE_PATH"):  # <6>
            return self.wait_for(  # <7>
                lambda: self.retrieve_email_from_file(sent_to, subject, email_file_path)
            )
        else:
            return self.retrieve_email_from_django_outbox(sent_to, subject)

    def test_login_using_magic_link(self):
        [...]
----
====

<1> Here's our helper method for getting email contents from a file.
    It takes the configured email directory as an argument,
    as well as the sent-to address and expected subject.

<2> Django saves a new file with emails every time you restart the server.
    The filename has a timestamp in it,
    so we can get the latest one by sorting the files in our test directory.
    Check out the https://docs.python.org/3/library/pathlib.html[Pathlib] docs
    if you haven't used it before, it's a nice, relatively new way of working with files in Python.

<3> The emails in the file are separated by a line of 80 hyphens.

<4> This is the matching helper for getting the email from `mail.outbox`.

<5> Here's where we dispatch to the right helper based on whether the env
    var is set.

<6> Checking whether an environment variable is set, and using its value if so,
    is one of the (relatively few) places where it's nice to use the walrus operator.

<7> I'm using a `wait_for()` here because anything involving reading and writing from files,
    especially across the filesystem mounts inside and outside of Docker,
    has a potential race condition.


We'll need a couple more minor changes to the FT, to use the helper:


[role="sourcecode"]
.src/functional_tests/test_login.py (ch23l004)
====
[source,diff]
----
@@ -59,15 +59,12 @@ class LoginTest(FunctionalTest):
         )

         # She checks her email and finds a message
-        email = mail.outbox.pop()
-        self.assertIn(TEST_EMAIL, email.to)
-        self.assertEqual(email.subject, SUBJECT)
+        email_body = self.wait_for_email(TEST_EMAIL, SUBJECT)

         # It has a URL link in it
-        self.assertIn("Use this link to log in", email.body)
-        url_search = re.search(r"http://.+/.+$", email.body)
-        if not url_search:
-            self.fail(f"Could not find url in email body:\n{email.body}")
+        self.assertIn("Use this link to log in", email_body)
+        if not (url_search := re.search(r"http://.+/.+$", email_body, re.MULTILINE)):
+            self.fail(f"Could not find url in email body:\n{email_body}")
         url = url_search.group(0)
         self.assertIn(self.live_server_url, url)
----
====

// TODO backport that walrus

Now let's set that file path, and mount it inside our docker container,
so that it's available both inside and outside the container:

[subs="specialcharacters,quotes"]
----
# set a local env var for our path to the emails file
$ *export EMAIL_FILE_PATH=/tmp/superlists-emails*
# make sure the file exists
$ *mkdir -p $EMAIL_FILE_PATH*
# re-run our container, with the EMAIL_FILE_PATH as an env var, and mounted.
$ *docker build -t superlists . && docker run \
    -p 8888:8888 \
    --mount type=bind,source=./src/db.sqlite3,target=/src/db.sqlite3 \
    --mount type=bind,source=$EMAIL_FILE_PATH,target=$EMAIL_FILE_PATH \  <1>
    -e DJANGO_SECRET_KEY=sekrit \
    -e DJANGO_ALLOWED_HOST=localhost \
    -e EMAIL_PASSWORD \
    -e EMAIL_FILE_PATH \  <2>
    -it superlists*
----

<1> Here's where we mount the emails file so we can see it
    both inside and outside the container

<2> And here's where we pass the path as an env var,
    once again re-exporting the variable from the current shell.


And we can re-run our FT, first without using Docker or the EMAIL_FILE_PATH,
just to check we didn't break anything:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*./src/manage.py test functional_tests.test_login*]
[...]
OK
----

And now _with_ Docker and the EMAIL_FILE_PATH.  Remember,

[subs="specialcharacters,quotes"]
----
# we need to set the EMAIL_FILE_PATH in this terminal too
$ *export EMAIL_FILE_PATH=/tmp/superlists-emails*
$ *TEST_SERVER=localhost:8888 python src/manage.py test functional_tests*
[...]
OK
----


It works!  Hooray.


==== Double-Checking our Test and Our Fix

As always, we should be suspicious of any test that we've only ever seen pass!
Let's see if we can make this test fail.

NOTE: You might have lost track of the actual bug and how we fixed it!
    The bug was, the server was crashing when it tried to send an email.
    The reason was, we hadn't set the `EMAIL_PASSWORD` environment variable.
    So the actual fix is to set that env var,
    and the way we _test_ that it works, is by using the `filebased.EmailBackend"
    `EMAIL_BACKEND` setting using the `EMAIL_FILE_PATH` environment variable.


So, how shall we make the test fail?
Well, how about if we deliberately break the email that the server sends:

TODO: filename/commit

[role="sourcecode"]
.lists.tests.py (ch04l004)
====
[source,python]
----
def send_login_email(request):
    email = request.POST["email"]
    token = Token.objects.create(email=email)
    url = request.build_absolute_uri(
        reverse("login") + "?token=" + str(token.uid),
    )
    message_body = f"Use this link to log in:\n\n{url}"
    send_mail(
        "Your login link for Superlists",
        "HAHA NO LOGIN URL FOR U",  # <1>
        "noreply@superlists",
        [email],
    )
    messages.success(
        request,
        "Check your email, we've sent you a link you can use to log in.",
    )
    return redirect("/")
----
====

<1> This should do it!  We'll still send an email,
    but it won't contain a login URL.


* TODO: aside on moujnting /src/?

So let's try it:


[subs="specialcharacters,quotes"]
----
$ *TEST_SERVER=localhost:8888 EMAIL_FILE_PATH=/tmp/superlists-emails ./src/manage.py test functional_tests.test_login
[...]
Ran 1 test in 2.513s

OK
----

==== Testing side-effects is fiddly!

TODO: flesh out explanation

eh?  what's happening?

It's because we're picking up an old email, which is still a valid token in the DB


Let's clear out the db:

[subs="specialcharacters,quotes"]
----
$ *rm src/db.sqlite3 && ./src/manage.py migrate*
Operations to perform:
  Apply all migrations: accounts, auth, contenttypes, lists, sessions
Running migrations:
  Applying accounts.0001_initial... OK
  Applying accounts.0002_token... OK
  Applying contenttypes.0001_initial... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0001_initial... OK
----


And...

cmdgg
[subs="specialcharacters,quotes"]
----
$ *TEST_SERVER=localhost:8888 ./src/manage.py test functional_tests.test_login*
[...]
ERROR: test_login_using_magic_link (functional_tests.test_login.LoginTest.test_login_using_magic_link)
    self.wait_to_be_logged_in(email=TEST_EMAIL)
    ~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate element: #id_logout; [...]
----

OK that's weird, it _does_ still find an email with a magic link in?

ah, it's an old one.


////
[subs="specialcharacters,quotes"]
----
$ *TEST_SERVER=localhost:8888 ./src/manage.py test functional_tests.test_login*
ERROR: test_login_using_magic_link
(functional_tests.test_login.LoginTest.test_login_using_magic_link)
[...]
    email_body = self.wait_for_email(TEST_EMAIL, SUBJECT)
[...]
    return self.wait_for(
           ~~~~~~~~~~~~~^
        lambda: self.retrieve_email_from_file(sent_to, subject, email_file_path)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[...]
    latest_emails_file = sorted(Path(emails_dir).iterdir())[-1]
                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^
IndexError: list index out of range
----

That's better!  We're not sending any emails, so there's no email file to find.
////

Let's delete all our old emails

[subs="specialcharacters,macros"]
----
$ pass:quotes[*rm $EMAIL_FILE_PATH/*]
----

And now re rerun the FT:

----
$ pass:quotes[*TEST_SERVER=localhost:8888 python src/manage.py test functional_tests*]
FAIL: test_login_using_magic_link
(functional_tests.test_login.LoginTest.test_login_using_magic_link)
[...]
    email_body = self.wait_for_email(TEST_EMAIL, SUBJECT)
[...]
    self.assertIn("Use this link to log in", email_body)
    ~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AssertionError: 'Use this link to log in' not found in 'Content-Type:
text/plain; charset="utf-8"\nMIME-Version: 1.0\nContent-Transfer-Encoding:
7bit\nSubject: Your login link for Superlists\nFrom: noreply@superlists\nTo:
edith@example.com\nDate: Wed, 13 Nov 2024 18:00:55 -0000\nMessage-ID:
[...]\n\nHAHA NO LOGIN URL FOR
U\n-------------------------------------------------------------------------------\n'
----


That's the error we wanted!


=== Setting Secret Environment Variables on the Server

((("debugging", "server-side", "setting secret environment variables")))
((("environment variables")))
((("secret values")))
Just as in <<chapter_11_server_prep>>,
the place we set environment variables on the server is in the _superlists.env_ file.
Let's change it manually, on the server, for a test:

* TODO: maybe use ansible straight away?  Also, need to discuss secret storage locally.

[role="server-commands small-code"]
[subs="specialcharacters,quotes"]
----
elspeth@server:$ *echo EMAIL_PASSWORD=yoursekritpasswordhere >> ~/superlists.env*
elspeth@server:$ *docker restart superlists*
----

Now if we rerun our FTs, we see a change:

[role="against-server small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*TEST_SERVER=staging.ottg.co.uk python src/manage.py test functional_tests*]

[...]
Traceback (most recent call last):
  File "...goat-book/functional_tests/test_login.py", line 28, in
test_login_using_magic_link
    email = mail.outbox[0]
IndexError: list index out of range

[...]

selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: Log out
----


The `my_lists` failure is still the same, but we have more information in our login test:
the FT gets further, and the site now looks like it's sending emails correctly
(and the server log no longer shows any errors),
but we can't check the email in the `mail.outbox`...


=== Adapting Our FT to Be Able to Test Real Emails via POP3

((("debugging", "server-side", "testing POP3 emails", id="DBservemail21")))
((("Django framework", "sending emails", id="DJFemail21")))
((("emails, sending from Django", id="email21")))

First, we'll need to know, in our FTs,
whether we're running against the staging server or not.
Let's save the `staging_server` variable on `self` in _base.py_:

[role="sourcecode"]
.src/functional_tests/base.py (ch21l009)
====
[source,python]
----
    def setUp(self):
        self.browser = webdriver.Firefox()
        self.test_server = os.environ.get("TEST_SERVER")
        if self.test_server:
            self.live_server_url = "http://" + self.test_server
----
====

And then we feed through the rest of the changes to the FT that are required
as a result.  Firstly, populating a `test_email` variable, differently for
local and staging tests:



[role="sourcecode small-code"]
.src/functional_tests/test_login.py (ch21l011-1)
====
[source,diff]
----
@@ -9,7 +9,6 @@ from selenium.webdriver.common.keys import Keys

 from .base import FunctionalTest

-TEST_EMAIL = "edith@example.com"
 SUBJECT = "Your login link for Superlists"


@@ -34,7 +33,6 @@ class LoginTest(FunctionalTest):
                     print("getting msg", i)
                     _, lines, __ = inbox.retr(i)
                     lines = [l.decode("utf8") for l in lines]
-                    print(lines)
                     if f"Subject: {subject}" in lines:
                         email_id = i
                         body = "\n".join(lines)
@@ -49,9 +47,14 @@ class LoginTest(FunctionalTest):
         # Edith goes to the awesome superlists site
         # and notices a "Log in" section in the navbar for the first time
         # It's telling her to enter her email address, so she does
+        if self.test_server:
+            test_email = "edith.testuser@yahoo.com"
+        else:
+            test_email = "edith@example.com"
+
         self.browser.get(self.live_server_url)
         self.browser.find_element(By.CSS_SELECTOR, "input[name=email]").send_keys(
-            TEST_EMAIL, Keys.ENTER
+            test_email, Keys.ENTER
         )
----
====

And then modifications involving using that variable and calling our new helper
function:

[role="sourcecode small-code"]
.src/functional_tests/test_login.py (ch21l011-2)
====
[source,diff]
----
@@ -69,15 +69,13 @@ class LoginTest(FunctionalTest):
         )

         # She checks her email and finds a message
-        email = mail.outbox[0]
-        self.assertIn(TEST_EMAIL, email.to)
-        self.assertEqual(email.subject, SUBJECT)
+        body = self.wait_for_email(test_email, SUBJECT)

-        # It has a URL link in it
-        self.assertIn("Use this link to log in", email.body)
-        url_search = re.search(r"http://.+/.+$", email.body)
+        # It has a url link in it
+        self.assertIn("Use this link to log in", body)
+        url_search = re.search(r"http://.+/.+$", body)
         if not url_search:
-            self.fail(f"Could not find url in email body:\n{email.body}")
+            self.fail(f"Could not find url in email body:\n{body}")
         url = url_search.group(0)
         self.assertIn(self.live_server_url, url)

@@ -85,10 +83,10 @@ class LoginTest(FunctionalTest):
         self.browser.get(url)

         # she is logged in!
-        self.wait_to_be_logged_in(email=TEST_EMAIL)
+        self.wait_to_be_logged_in(email=test_email)

         # Now she logs out
         self.browser.find_element(By.LINK_TEXT, "Log out").click()

         # She is logged out
-        self.wait_to_be_logged_out(email=TEST_EMAIL)
+        self.wait_to_be_logged_out(email=test_email)
----
====


And, believe it or not, that'll actually work, and give us an FT
that can actually check for logins that work, involving real emails!


[role="against-server small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*TEST_SERVER=staging.ottg.co.uk python src/manage.py test functional_tests.test_login*]
[...]
OK
----

NOTE: I've just hacked this email-checking code together,
    and it's currently pretty ugly and brittle
    (one common problem is picking up the wrong email from a previous test run).
    With some cleanup and a few more retry loops
    it could grow into something more reliable.
    Alternatively, services like _mailinator.com_ will give you throwaway email addresses
    and an API to check them, for a small fee.
    ((("", startref="email21")))
    ((("", startref="DJFemail21")))
    ((("", startref="DBservemail21")))


=== Managing the Test Database on Staging

((("debugging", "server-side", "managing test databases", id="DBservdatabase21")))
((("staging sites", "managing test databases", id="SSmanag21")))
((("database testing", "managing test databases", id="DTmanag21")))
((("sessions, pre-creating")))
Now we can rerun our full FT suite and get to the next failure:
our attempt to create pre-authenticated sessions doesn't work,
so the "My Lists" test fails:

[role="skipme small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*TEST_SERVER=staging.ottg.co.uk python src/manage.py test functional_tests*]

ERROR: test_logged_in_users_lists_are_saved_as_my_lists
(functional_tests.test_my_lists.MyListsTest)
[...]
selenium.common.exceptions.TimeoutException: Message: Could not find element
with id id_logout. Page text was:
Superlists
Sign in
Start a new To-Do list

Ran 8 tests in 72.742s

FAILED (errors=1)
----

It's because our test utility function `create_pre_authenticated_session` only
acts on the local database. Let's find out how our tests can manage the
database on the server.



==== A Django Management Command to Create Sessions

((("scripts, building standalone")))
To do things on the server, we'll need to build a self-contained script
that can be run from the command line on the server, most probably via Fabric.

When trying to build a standalone script that works with Django (i.e., can talk
to the database and so on), there are some fiddly issues you need to get right,
like setting the `DJANGO_SETTINGS_MODULE` environment variable, and getting
`sys.path` correctly.

Instead of messing about with all that, Django lets you create your own
"management commands" (commands you can run with `python manage.py`), which
will do all that path mangling for you. They live in a folder called
'management/commands' inside your apps:

[subs=""]
----
$ <strong>mkdir -p src/functional_tests/management/commands</strong>
$ <strong>touch src/functional_tests/management/__init__.py</strong>
$ <strong>touch src/functional_tests/management/commands/__init__.py</strong>
----
//ch21l012-1

The boilerplate in a management command is a class that inherits from
`django.core.management.BaseCommand`, and that defines a method called
`handle`:

[role="sourcecode"]
.src/functional_tests/management/commands/create_session.py (ch21l012)
====
[source,python]
----
from django.conf import settings
from django.contrib.auth import BACKEND_SESSION_KEY, SESSION_KEY, get_user_model
from django.contrib.sessions.backends.db import SessionStore
from django.core.management.base import BaseCommand

User = get_user_model()


class Command(BaseCommand):
    def add_arguments(self, parser):
        parser.add_argument("email")

    def handle(self, *args, **options):
        session_key = create_pre_authenticated_session(options["email"])
        self.stdout.write(session_key)


def create_pre_authenticated_session(email):
    user = User.objects.create(email=email)
    session = SessionStore()
    session[SESSION_KEY] = user.pk
    session[BACKEND_SESSION_KEY] = settings.AUTHENTICATION_BACKENDS[0]
    session.save()
    return session.session_key
----
====

We've taken the code for `create_pre_authenticated_session` from
'test_my_lists.py'. `handle` will pick up an email address from the parser,
and then return the session key that we'll want to add to our browser cookies,
and the management command prints it out at the command line. Try it out:

[role="ignore-errors"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py create_session a@b.com*]
Unknown command: 'create_session'. Did you mean clearsessions?
----

One more step: we need to add `functional_tests` to our 'settings.py'
for it to recognise it as a real app that might have management commands as
well as tests:

[role="sourcecode"]
.src/superlists/settings.py (ch21l014)
====
[source,python]
----
+++ b/superlists/settings.py
@@ -42,6 +42,7 @@ INSTALLED_APPS = [
     "lists",
     "accounts",
+    "functional_tests",
 ]
----
====
//14

Now it works:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py create_session a@b.com*]
qnslckvp2aga7tm6xuivyb0ob1akzzwl
----

NOTE: If you see an error saying the `auth_user` table is missing, you may need
    to run `manage.py migrate`.  In case that doesn't work, delete the
    _db.sqlite3_ file and run +migrate+ again, to get a clean slate.


==== Getting the FT to Run the Management Command on the Server

Next we need to adjust `test_my_lists` so that it runs the local function
when we're on the local server,
and make it run the management command on the staging server if we're on that:

[role="sourcecode"]
.src/functional_tests/test_my_lists.py (ch21l016)
====
[source,python]
----
from django.conf import settings

from .base import FunctionalTest
from .management.commands.create_session import create_pre_authenticated_session
from .server_tools import create_session_on_server


class MyListsTest(FunctionalTest):
    def create_pre_authenticated_session(self, email):
        if self.test_server:
            session_key = create_session_on_server(self.test_server, email)
        else:
            session_key = create_pre_authenticated_session(email)

        ## to set a cookie we need to first visit the domain.
        ## 404 pages load the quickest!
        self.browser.get(self.live_server_url + "/404_no_such_url/")
        self.browser.add_cookie(
            dict(
                name=settings.SESSION_COOKIE_NAME,
                value=session_key,
                path="/",
            )
        )

    [...]
----
====


Let's also tweak _base.py_, to gather a bit more information
when we populate `self.test_server`:


[role="sourcecode"]
.src/functional_tests/base.py (ch21l017)
====
[source,python]
----
from .server_tools import reset_database  #<1>
[...]

class FunctionalTest(StaticLiveServerTestCase):
    def setUp(self):
        self.browser = webdriver.Firefox()
        self.test_server = os.environ.get("TEST_SERVER")
        if self.test_server:
            self.live_server_url = "http://" + self.test_server
            reset_database(self.test_server)  #<1>
----
====

<1> This will be our function to reset the server database in between each
    test.  We'll write that next, using Fabric.




==== Using Fabric Directly from Python

* TODO: rewrite for ansible.

((("Fabric", "using directly from Python")))
Rather than using the `fab` command, Fabric provides an API that lets
you run Fabric server commands directly inline in your Python code.  You
just need to let it know the "host string" you're connecting to:



[role="sourcecode"]
.src/functional_tests/server_tools.py (ch18l018)
====
[source,python]
----
from fabric.api import run
from fabric.context_managers import settings, shell_env


def _get_manage_dot_py(host):
    return f"~/sites/{host}/.venv/bin/python ~/sites/{host}/manage.py"


def reset_database(host):
    manage_dot_py = _get_manage_dot_py(host)
    with settings(host_string=f"elspeth@{host}"):  # <1>
        run(f"{manage_dot_py} flush --noinput")  # <2>
----
====

<1> Here's the context manager that sets the host string, in the form
    'user@server-address' (I've hardcoded my server username, elspeth, so
    adjust as necessary).

<2> Then, once we're inside the context manager, we can just call
    Fabric commands as if we're in a fabfile.


For creating the session, we have a slightly more complex procedure,
because we need to extract the `SECRET_KEY` and other env vars from
the current running server, to be able to generate a session key that's
cryptographically valid for the server:


[role="sourcecode small-code"]
.src/functional_tests/server_tools.py (ch18l019)
====
[source,python]
----
def _get_server_env_vars(host):
    env_lines = run(f"cat ~/sites/{host}/.env").splitlines()  # <1>
    return dict(l.split("=") for l in env_lines if l)


def create_session_on_server(host, email):
    manage_dot_py = _get_manage_dot_py(host)
    with settings(host_string=f"elspeth@{host}"):
        env_vars = _get_server_env_vars(host)
        with shell_env(**env_vars):  # <2>
            session_key = run(f"{manage_dot_py} create_session {email}")  # <3>
            return session_key.strip()
----
====


<1> We extract and parse the server's current environment variables from the
    _.env_ file...

<2> In order to use them in another fabric context manager, `shell_env`,
    which sets the environment for the next command...

<3> Which is to run our `create_session` management command, which calls the
    same `create_pre_authenticated_session` function, but on the server.



==== Recap: Creating Sessions Locally Versus Staging

((("staging sites", "local vs. staged sessions")))
Does that all make sense?
Perhaps a little ascii-art diagram will help:



===== Locally:

[role="skipme small-code"]
----

+-----------------------------------+       +-------------------------------------+
| MyListsTest                       |  -->  | .management.commands.create_session |
| .create_pre_authenticated_session |       |  .create_pre_authenticated_session  |
|            (locally)              |       |             (locally)               |
+-----------------------------------+       +-------------------------------------+

----

===== Against staging:

[role="skipme small-code"]
----
+-----------------------------------+       +-------------------------------------+
| MyListsTest                       |       | .management.commands.create_session |
| .create_pre_authenticated_session |       |  .create_pre_authenticated_session  |
|            (locally)              |       |            (on server)              |
+-----------------------------------+       +-------------------------------------+
            |                                                   ^
            v                                                   |
+----------------------------+     +--------+      +------------------------------+
| server_tools               | --> | fabric | -->  | ./manage.py create_session   |
| .create_session_on_server  |     |  "run" |      |   (on server, using .env)    |
|        (locally)           |     +--------+      +------------------------------+
+----------------------------+

----

In any case, let's see if it works.  First, locally, to check that we didn't
break anything:


[role="dofirst-ch21l022"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python src/manage.py test functional_tests.test_my_lists*]
[...]
OK
----


Next, against the server.


[role="against-server"]
[subs="specialcharacters,quotes"]
----
$ pass:quotes[*ansible-playbook --user=elspeth -i staging.ottg.co.uk, infra/deploy-playbook.yaml.yaml -vv*]
----

And now we run the test:


[role="against-server small-code"]
[subs=""]
----
$ <strong>TEST_SERVER=staging.ottg.co.uk python src/manage.py test \
 functional_tests.test_my_lists</strong>
[...]
[elspeth@staging.ottg.co.uk] run:
~/sites/staging.ottg.co.uk/.venv/bin/python
~/sites/staging.ottg.co.uk/manage.py flush --noinput
[...]
[elspeth@staging.ottg.co.uk] run:
~/sites/staging.ottg.co.uk/.venv/bin/python
~/sites/staging.ottg.co.uk/manage.py create_session edith@example.com
[...]
.
 ---------------------------------------------------------------------
Ran 1 test in 5.701s

OK
----

Looking good!  We can rerun all the tests to make sure...

[role="against-server small-code"]
[subs=""]
----
$ <strong>TEST_SERVER=staging.ottg.co.uk python src/manage.py test functional_tests</strong>
[...]
[elspeth@staging.ottg.co.uk] run:
~/sites/staging.ottg.co.uk/.venv/bin/python
[...]
Ran 8 tests in 89.494s

OK
----

Hooray!

NOTE: I've shown one way of managing the test database, but you could
    experiment with others--for example, if you were using MySQL or Postgres,
    you could open up an SSH tunnel to the server, and use port forwarding to
    talk to the database directly.  You could then amend `settings.DATABASES`
    during FTs to talk to the tunnelled port.  You'd still need some way of
    pulling in the staging server environment variables though.((("", startref="DBservdatabase21")))((("", startref="SSmanag21")))((("", startref="DTmanag21")))



[role="pagebreak-before less_space"]
.Warning: Be Careful Not to Run Test Code Against the Live Server
*******************************************************************************
((("database testing", "safeguarding production databases")))
((("production databases")))
We're into dangerous territory,
now that we have code that can directly affect a database on the server.
You want to be very, very careful
that you don't accidentally blow away your production database
by running FTs against the wrong host.

You might consider putting some safeguards in place at this point.
For example, you could put staging and production on different servers,
and make it so they use different keypairs for authentication, with different passphrases.

This is similarly dangerous territory to running tests against clones of production data.
I have a little story about accidentally sending thousands of duplicate invoices to clients
in <<data-migrations-appendix>>. LFMF.

*******************************************************************************


=== Updating our Deploy Script

* TODO: ansible.

((("debugging", "server-side", "baking in logging code")))
Before we finish, let's update our deployment fabfile so that it can
automatically add the `EMAIL_PASSWORD` to the _.env_ file on the server:


[role="sourcecode skipme"]
.src/deploy_tools/fabfile.py (ch18l021)
====
[source,python]
----
import os
[...]


def _create_or_update_dotenv():
    append(".env", "DJANGO_DEBUG_FALSE=y")
    append(".env", f"SITENAME={env.host}")
    current_contents = run("cat .env")
    if "DJANGO_SECRET_KEY" not in current_contents:
        new_secret = "".join(
            random.SystemRandom().choices("abcdefghijklmnopqrstuvwxyz0123456789", k=50)
        )
        append(".env", f"DJANGO_SECRET_KEY={new_secret}")
    email_password = os.environ["EMAIL_PASSWORD"]  # <1>
    append(".env", f"EMAIL_PASSWORD={email_password}")  # <1>
----
====

<1> We just add two lines at the end of the script which will essentially
    copy the local `EMAIL_PASSWORD` environment variable up to the server's
    _.env_ file.



=== Wrap-Up

Actually getting your new code up and running on a server always tends to
flush out some last-minute bugs and unexpected issues.  We had to do a bit
of work to get through them, but we've ended up with several useful things
as a result.

We now have a lovely generic `wait` decorator which will be a nice Pythonic
helper for our FTs from now on.  We have test fixtures that work both
locally and on the server, including the ability to test "real" email
integration. And we've got some more robust logging configuration.

But before we can deploy our actual live site, we'd better actually give the
users what they wanted--the next chapter describes how to give them
the ability to save their lists on a "My Lists" page.


.Lessons Learned Catching Bugs in Staging
*******************************************************************************

Fixtures also have to work remotely::
    `LiveServerTestCase` makes it easy to interact with the test database
    using the Django ORM for tests running locally.  Interacting with the
    database on the staging server is not so straightforward. One solution
    is Fabric and Django management commands, as I've shown, but you should
    explore what works for you--SSH tunnels, for example.
    ((("fixtures", "staging and")))
    ((("staging sites", "fixtures and")))

Be very careful when resetting data on your servers::
    A command that can remotely wipe the entire database on one of your
    servers is a dangerous weapon, and you want to be really, really sure
    it's never accidentally going to hit your production data.
    ((("database testing", "safeguarding production databases")))
    ((("production databases")))

Logging is critical to debugging issues on the server::
    At the very least, you'll want to be able to see any error messages
    that are being generated by the server.  For thornier bugs, you'll also
    want to be able to do the occasional "debug print", and see it end up
    in a file somewhere.
    ((("logging")))
    ((("debugging", "server-side", "baking in logging code")))

*******************************************************************************

